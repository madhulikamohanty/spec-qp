package de.mpii.trinitreloaded.queryprocessing;

import gnu.trove.list.TDoubleList;
import gnu.trove.list.array.TDoubleArrayList;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import com.google.common.collect.Lists;

import de.mpii.trinitreloaded.datastructures.Answer;
import de.mpii.trinitreloaded.datastructures.LogicalQueryPlan;
import de.mpii.trinitreloaded.datastructures.TriplePattern;
import de.mpii.trinitreloaded.datastructures.TriplePatternInPlan;
import de.mpii.trinitreloaded.utils.Config;
import de.mpii.trinitreloaded.utils.Config.LoggingLevel;
import de.mpii.trinitreloaded.utils.DBConnection;
import de.mpii.trinitreloaded.utils.Logger;

/**
 * Executes the {@link LogicalQueryPlan} generated by {@link QueryPlanner} using the correct order
 * of {@link Operator}.
 *
 * Following construction, the entry point is {@code translate()}.
 *
 * @author Madhulika Mohanty (madhulikam@cse.iitd.ac.in)
 *
 */
public class CodeGen {

  public final LogicalQueryPlan queryPlan;

  public CodeGen(LogicalQueryPlan queryPlan) {
    this.queryPlan = queryPlan;
  }

  @Deprecated
  public Operator translate() {

    Set<TriplePatternInPlan> plan = queryPlan.getPlan();

    List<Operator> ops = Lists.newArrayList();
    List<ArrayList<String>> variables = new ArrayList<ArrayList<String>>();

    /**
     * Create {@link IncrementalMerge} for single {@link TriplePattern}. Create
     * {@link PopularityBasedDBJoinSort} for conjunctive queries. Create {@link RankJoin} for all
     * the operators.
     */
    for (TriplePatternInPlan querySubset : plan) {
      switch (querySubset.getTPSet().size()) {
      case 1:
        ops.add(createIncrementalMerge(querySubset));
        ArrayList<String> vars = new ArrayList<String>();
        ArrayList<TriplePattern> tp = new ArrayList<TriplePattern>();
        tp.addAll(querySubset.getTPSet());
        for (String var : tp.get(0).variables()) {
          if (!vars.contains(var)) {
            vars.add(var);
          }
        }
        variables.add(vars);
        break;
      default:
        ops.add(createJoinSort(querySubset.getTPSet()));
        ArrayList<String> vars2 = new ArrayList<String>();
        ArrayList<TriplePattern> tp2 = new ArrayList<TriplePattern>();
        tp2.addAll(querySubset.getTPSet());
        for (int i = 0; i < tp2.size(); i++) {
          for (String var : tp2.get(i).variables()) {
            if (!vars2.contains(var)) {
              vars2.add(var);
            }
          }
        }
        variables.add(vars2);
        break;
      }
    }

    if (ops.size() == 1) {
      return ops.get(0);
    } else {
      return createRankJoin(ops, variables);
    }
  }

  public Operator createRankJoin(List<Operator> ops, List<ArrayList<String>> variables) {
    Operator op = new RankJoinCodeGen(ops, variables).translate();
    return op;
  }

  @SuppressWarnings("deprecation")
  public Operator createJoinSort(Set<TriplePattern> querySubset) {
    ArrayList<TriplePattern> inputs = new ArrayList<TriplePattern>();
    inputs.addAll(querySubset);
    if(Config.isSyntheticData){
      SyntheticDBJoinSort js = new SyntheticDBJoinSort(inputs);
      return js;
    }
    else{
      PopularityBasedDBJoinSort js = new PopularityBasedDBJoinSort(inputs);
      return js;
    }
  }

  public Operator createIncrementalMerge(TriplePatternInPlan querySubset) {
    assert (querySubset.getTPSet().size() == 1);
    IncrementalMerge icm = null;
    for (TriplePattern tp : querySubset.getTPSet()) {
      Operator original;
      
      if(Config.isSyntheticData){
        if(Config.isRDFDB)
          original = new SyntheticRDFScan(tp);
        else
          original = new SyntheticScan(tp);
      }
      else if(Config.isRDFDB){
        original = new PopularityBasedRDFScan(tp);
      } 
      else
      {
        original = new PopularityBasedScan(tp);
      }
      
      if(!querySubset.isRelaxed){
        return original;
      }
      IncrementalMergeParameters imp = new IncrementalMergeParameters(tp);
      imp.generateParameters();
      if (imp.relaxations.size() == 0) {
        return original;
      } else {
        Logger.println("CodeGen:Creating Inc Merge with parameters:" + original + " "
            + imp.relaxations + " " + imp.weights + " " + imp.initialScores,
            LoggingLevel.INTERMEDIATEINFO);
        icm = new IncrementalMerge(original, imp.relaxations, imp.weights, imp.initialScores);
      }
    }
    return icm;
  }

  public class IncrementalMergeParameters {
    public List<Operator> relaxations;
    public TDoubleList weights;
    public TDoubleList initialScores;
    private final TriplePattern triplePattern;
    private double minScore;

    public IncrementalMergeParameters(TriplePattern tp) {
      this.triplePattern = tp;
      this.relaxations = new ArrayList<Operator>();
      this.weights = new TDoubleArrayList();
      this.initialScores = new TDoubleArrayList();
    }

    public void generateParameters() {
      Operator sc;
      
      if(Config.isSyntheticData){
        if(Config.isRDFDB)
          sc = new SyntheticRDFScan(triplePattern, false);
        else
          sc = new SyntheticScan(triplePattern, false);
      }
      else if(Config.isRDFDB){
        sc = new PopularityBasedRDFScan(triplePattern, false);
      } 
      else
      {
        sc = new PopularityBasedScan(triplePattern, false);
      }

      try {
        sc.open();
        minScore = 0.0;
        while (sc.hasNext()) {
          Answer a = sc.next();
          minScore = a.getScore();
        }
      } catch (Exception e) {
        e.printStackTrace();
      } finally {
        try {
          if (sc != null) {
            sc.close();
          }
        } catch (Exception e) {
        }
      }
      if(Config.isSyntheticData){
        generateSyntheticParameters();
      }
      else{
        generateOriginalParameters();
      }

    }

    private void generateOriginalParameters() {
      String relaxationRelationalTable = null;
      String seekField = null, fetchField1 = null, fetchField2 = null;
      int field;

      /**
       * Check if Object is to be relaxed.
       */
      field=2;
      if(this.triplePattern.isObjectConst){
        if (this.triplePattern.isObjectResource) { 
          seekField = "semantic_type"; 
          relaxationRelationalTable = Config.semanticTextualParaphrasesTblName;
          fetchField1 = "textual_type";
          fetchField2 = "prob_textual_type_given_semantic_type";
        } else {
          seekField = "textual_type";
          relaxationRelationalTable = Config.textualSemanticParaphrasesTblName;
          fetchField1 = "semantic_type";
          fetchField2 = "prob_semantic_type_given_textual_type";
        }
        fetchAndAddRelaxations(fetchField1, fetchField2, relaxationRelationalTable, seekField, field);
      }

      if(!Config.onlyObjectRelaxed){
        /**
         * Check if Predicate is to be relaxed.
         */
        field=1;
        if(this.triplePattern.isPredicateConst){
          if (this.triplePattern.isPredicateResource) { 
            seekField = "predicate";
            relaxationRelationalTable = Config.predicateRelationParaphraseTblName;
            fetchField1 = "relation";
            fetchField2 = "cp";
          } else if(!this.triplePattern.isPredicateResource){
            seekField = "relation";
            relaxationRelationalTable = Config.relationRelationParaphraseTblName;
            fetchField1 = "paraphrase";
            fetchField2 = "cp";
          }
          fetchAndAddRelaxations(fetchField1, fetchField2, relaxationRelationalTable, seekField, field);
        }

        /**
         * Check if Subject is to be relaxed.
         */
        field=0;
        if(this.triplePattern.isSubjectConst){
          if (this.triplePattern.isSubjectResource) { 
            seekField = "semantic_type"; 
            relaxationRelationalTable = Config.semanticTextualParaphrasesTblName;
            fetchField1 = "textual_type";
            fetchField2 = "prob_textual_type_given_semantic_type";
          } else if(!this.triplePattern.isSubjectResource){
            seekField = "textual_type";
            relaxationRelationalTable = Config.textualSemanticParaphrasesTblName;
            fetchField1 = "semantic_type";
            fetchField2 = "prob_semantic_type_given_textual_type";
          }
          fetchAndAddRelaxations(fetchField1, fetchField2, relaxationRelationalTable, seekField, field);
        }
      }
      Logger.println("No. of relaxations for "+this.triplePattern+" is:"+this.weights.size(), LoggingLevel.INTERMEDIATEINFO);
      Logger.println("Relaxations for "+this.triplePattern+" is:"+this.relaxations, LoggingLevel.INTERMEDIATEINFO);
    }

    private void fetchAndAddRelaxations(String fetchField1, String fetchField2, String relaxationRelationalTable,
        String seekField, int field) {

      String seekFieldVal = "";
      switch(field){
      case 0:
        seekFieldVal = this.triplePattern.subject;
        break;
      case 1:
        seekFieldVal = this.triplePattern.predicate;
        break;
      case 2:
        seekFieldVal = this.triplePattern.object;
        break;
      }

      Connection conn = null;
      Statement statement = null;
      ResultSet rs = null;
      try {
        conn = DBConnection.getConnection();
        String cmd =
            "SELECT " + fetchField1 + "," + fetchField2 + " FROM " + relaxationRelationalTable
            + " WHERE " + seekField + " = '" + seekFieldVal + "' ORDER BY "
            + fetchField2 + " DESC LIMIT " + Config.numOfRelaxations; // Limiting the no. of
        // relaxations to a fixed
        // number.
        Logger.print("Getting relaxations:" + cmd, LoggingLevel.INTERMEDIATEINFO);
        statement = conn.createStatement();
        rs = statement.executeQuery(cmd);

        while (rs.next()) {
          String relaxation = rs.getString(fetchField1);
          double weight = rs.getDouble(fetchField2);

          TriplePattern newTP = null;
          switch(field){
          case 0:
            newTP = new TriplePattern(
                relaxation, this.triplePattern.predicate, this.triplePattern.object);
            break;
          case 1:
            newTP = new TriplePattern(
                this.triplePattern.subject, relaxation, this.triplePattern.object);
            break;
          case 2:
            newTP = new TriplePattern(
                this.triplePattern.subject, this.triplePattern.predicate, relaxation);
            break;
          }
          // TODO : use a class InitialScanParameters to fetch these values.
          PopularityBasedScan relaxScan =
              new PopularityBasedScan(newTP, false);
          relaxScan.open();
          Answer a = null;
          if (relaxScan.hasNext()) {
            a = relaxScan.next();
          }
          if (a != null) {
            if(this.weights.size()>=Config.numOfRelaxations){
              int indexI = -1;
              double minWeight = Double.MAX_VALUE;
              for(int index=0; index <this.weights.size();index++){
                double wts = this.weights.get(index);
                if(minWeight>wts){
                  minWeight = wts;
                  indexI = index;
                }
              }
              if(weight>minWeight){ // If the current relaxation has a weight higher than the lowest weight till now, replace it.
                //System.out.println("Resetting weights!!!!");
                double initialScore = a.getScore();
                if(Config.isRDFDB)
                  this.relaxations.set(indexI,new PopularityBasedRDFScan(newTP));
                else
                  this.relaxations.set(indexI,new PopularityBasedScan(newTP));
                this.initialScores.set(indexI, initialScore);
                if(Config.isIncrementalWeighting)
                  this.weights.set(indexI, weight*this.minScore);
                else
                  this.weights.set(indexI, weight);
              }
            }
            else{
              double initialScore = a.getScore();
              if(Config.isRDFDB)
                this.relaxations.add(new PopularityBasedRDFScan(newTP));
              else
                this.relaxations.add(new PopularityBasedScan(newTP));
              this.initialScores.add((initialScore));
              if(Config.isIncrementalWeighting)
                this.weights.add(weight*this.minScore);
              else
                this.weights.add(weight);
            }
          }
          relaxScan.close();
        }
      } catch (SQLException e) {
        e.printStackTrace();
      } catch (Exception e) {
        e.printStackTrace();
      } finally {
        try {
          if (rs != null) {
            rs.close();
          }
          if (statement != null) {
            statement.close();
          }
          if (conn != null) {
            conn.close();
          }
        } catch (Exception e) {
        }
      }

    }

    private void generateSyntheticParameters() {
      String relaxationRelationalTable;
      String seekField, fetchField1, fetchField2;

      /**
       * Checking for relaxation only for object for Synthetic Data (Twitter).
       */
      if (this.triplePattern.isObjectResource) { 
        seekField = "semantic_type"; 
        relaxationRelationalTable = Config.syntheticParaphraseTblName;
        fetchField1 = "textual_type";
        fetchField2 = "prob_textual_type_given_semantic_type";
      } else {
        seekField = "textual_type";
        relaxationRelationalTable = Config.syntheticParaphraseTblName;
        fetchField1 = "semantic_type";
        fetchField2 = "prob_semantic_type_given_textual_type";
      }
      Connection conn = null;
      Statement statement = null;
      ResultSet rs = null;
      try {
        conn = DBConnection.getConnection();
        String cmd =
            "SELECT " + fetchField1 + "," + fetchField2 + " FROM " + relaxationRelationalTable
            + " WHERE " + seekField + " = '" + this.triplePattern.object + "' ORDER BY "
            + fetchField2 + " DESC LIMIT " + Config.numOfRelaxations; // Limiting the no. of
        // relaxations to a fixed
        // number.
        Logger.print("Getting relaxations:" + cmd, LoggingLevel.INTERMEDIATEINFO);
        statement = conn.createStatement();
        rs = statement.executeQuery(cmd);

        while (rs.next()) {
          String relaxation = rs.getString(fetchField1);
          double weight = rs.getDouble(fetchField2);
          // TODO : use a class InitialScanParameters to fetch these values.
          SyntheticScan relaxScan =
              new SyntheticScan(new TriplePattern(this.triplePattern.subject,
                  this.triplePattern.predicate, relaxation), false);
          relaxScan.open();
          Answer a = null;
          if (relaxScan.hasNext()) {
            a = relaxScan.next();
          }
          if (a != null) {
            double initialScore = a.getScore();
            if(Config.isRDFDB)
              this.relaxations.add(new SyntheticRDFScan(new TriplePattern(
                  this.triplePattern.subject, this.triplePattern.predicate, relaxation)));
            else
              this.relaxations.add(new SyntheticScan(new TriplePattern(
                this.triplePattern.subject, this.triplePattern.predicate, relaxation)));
            this.initialScores.add((initialScore));
            if(Config.isIncrementalWeighting)
              this.weights.add(weight*this.minScore);
            else
              this.weights.add(weight);
          }
          relaxScan.close();
        }
      } catch (SQLException e) {
        e.printStackTrace();
      } catch (Exception e) {
        e.printStackTrace();
      } finally {
        try {
          if (rs != null) {
            rs.close();
          }
          if (statement != null) {
            statement.close();
          }
          if (conn != null) {
            conn.close();
          }
        } catch (Exception e) {
        }
      }

    }
  }

}
